/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2020 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rlp_test

import (
	"testing"

	"github.com/onflow/cadence/runtime/interpreter/rlp"
	"github.com/stretchr/testify/require"
)

func TestRLPReadBytesItem(t *testing.T) {
	tests := []struct {
		inp     string
		encoded []byte
	}{
		{"A",
			[]byte{0x41},
		},
		{"dog",
			[]byte{0x83, 0x64, 0x6f, 0x67},
		},
		{"this is a test lo0o0o0o0o0ong string with 55 characters",
			[]byte{0xb7, // one byte size
				0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
				0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x6c,
				0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30,
				0x6f, 0x30, 0x6f, 0x6e, 0x67, 0x20, 0x73, 0x74,
				0x72, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x35, 0x35, 0x20, 0x63, 0x68, 0x61,
				0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73},
		},
		{"this is a test lo0o0o0o0o0o0ng string with 56 characters",
			[]byte{0xb8, 0x38, // an extra byte for size
				0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
				0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x6c,
				0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30,
				0x6f, 0x30, 0x6f, 0x30, 0x6e, 0x67, 0x20, 0x73,
				0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69,
				0x74, 0x68, 0x20, 0x35, 0x36, 0x20, 0x63, 0x68,
				0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73},
		},
		{"Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " +
			"Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus" +
			" et magnis dis parturient montes, nascetur ridiculus mus.",
			[]byte{0xb8, 0xbf, // two byte sizes
				0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75,
				0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69,
				0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f,
				0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x65, 0x72,
				0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e,
				0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x65,
				0x6e, 0x65, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
				0x64, 0x6f, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x20,
				0x65, 0x67, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72,
				0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x6d,
				0x61, 0x73, 0x73, 0x61, 0x2e, 0x20, 0x43, 0x75, 0x6d, 0x20,
				0x73, 0x6f, 0x63, 0x69, 0x69, 0x73, 0x20, 0x6e, 0x61, 0x74,
				0x6f, 0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x6e, 0x61, 0x74,
				0x69, 0x62, 0x75, 0x73, 0x20, 0x65, 0x74, 0x20, 0x6d, 0x61,
				0x67, 0x6e, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x20, 0x70,
				0x61, 0x72, 0x74, 0x75, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x20,
				0x6d, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x6e, 0x61,
				0x73, 0x63, 0x65, 0x74, 0x75, 0x72, 0x20, 0x72, 0x69, 0x64,
				0x69, 0x63, 0x75, 0x6c, 0x75, 0x73, 0x20, 0x6d, 0x75, 0x73,
				0x2e},
		},
		{"Lorem ipsum dolor sit amet, consectetur adipiscing elit. " +
			"Sed imperdiet odio a nibh rutrum blandit. Phasellus porta " +
			"eleifend tellus non consequat. Donec sodales velit in tortor " +
			"iaculis, sollicitudin dignissim orci maximus. Nunc at est sem. Sed congue proin.",
			[]byte{0xb9, 0x01, 0x00, // three bytes for size (256 chars) - checks big endian encoding
				0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d,
				0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20,
				0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65,
				0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70,
				0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74,
				0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x65, 0x72,
				0x64, 0x69, 0x65, 0x74, 0x20, 0x6f, 0x64, 0x69, 0x6f, 0x20, 0x61,
				0x20, 0x6e, 0x69, 0x62, 0x68, 0x20, 0x72, 0x75, 0x74, 0x72, 0x75,
				0x6d, 0x20, 0x62, 0x6c, 0x61, 0x6e, 0x64, 0x69, 0x74, 0x2e, 0x20,
				0x50, 0x68, 0x61, 0x73, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x70,
				0x6f, 0x72, 0x74, 0x61, 0x20, 0x65, 0x6c, 0x65, 0x69, 0x66, 0x65,
				0x6e, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x6e,
				0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61,
				0x74, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x73, 0x6f,
				0x64, 0x61, 0x6c, 0x65, 0x73, 0x20, 0x76, 0x65, 0x6c, 0x69, 0x74,
				0x20, 0x69, 0x6e, 0x20, 0x74, 0x6f, 0x72, 0x74, 0x6f, 0x72, 0x20,
				0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x73, 0x6f,
				0x6c, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x75, 0x64, 0x69, 0x6e, 0x20,
				0x64, 0x69, 0x67, 0x6e, 0x69, 0x73, 0x73, 0x69, 0x6d, 0x20, 0x6f,
				0x72, 0x63, 0x69, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x73,
				0x2e, 0x20, 0x4e, 0x75, 0x6e, 0x63, 0x20, 0x61, 0x74, 0x20, 0x65,
				0x73, 0x74, 0x20, 0x73, 0x65, 0x6d, 0x2e, 0x20, 0x53, 0x65, 0x64,
				0x20, 0x63, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x20, 0x70, 0x72, 0x6f,
				0x69, 0x6e, 0x2e},
		},
	}

	for _, test := range tests {
		item, nextIndex, err := rlp.ReadBytesItem(test.encoded, 0)
		require.NoError(t, err)
		require.Equal(t, nextIndex, len(test.encoded))
		require.Equal(t, string(item), test.inp)

	}
}

func TestRLPReadListItem(t *testing.T) {

	// TODO convert this into a list of test cases
	// TODO invalid chars ?

	// TODO add a single item string

	tests := []struct {
		items   []rlp.Item
		encoded []byte
	}{
		{
			[]rlp.Item{rlp.BytesItem("A")}, // single element
			[]byte{0xc1, 0x41},
		},
		{
			[]rlp.Item{
				rlp.BytesItem("ABCDEFG"),
				rlp.BytesItem("HIJKLMN"),
			}, // two short string elements
			[]byte{0xd0, // number of elements in a short list
				0x87,                                     // size of string
				0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, // content
				0x87,                                     // size of string
				0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, // content
			},
		},
		{
			[]rlp.Item{
				rlp.BytesItem("AB"),
				rlp.BytesItem("CD"),
				rlp.BytesItem("EF"),
				rlp.BytesItem(""),
				rlp.BytesItem("GH"),
				rlp.BytesItem(""),
			},
			[]byte{0xce, 0x82, 0x41, 0x42, 0x82, 0x43, 0x44, 0x82, 0x45, 0x46, 0x80, 0x82, 0x47, 0x48, 0x80},
		},

		// sample merkle tree full node encoding
		// []byte{0xf9, 0x01, 0x80, 0xaf, 0x0d, 0x07, 0x0a, 0x00, 0x7b, 0x0f, 0x00, 0x43, 0x03, 0x90, 0x0f, 0xa3, 0x06, 0x0b, 0x12, 0x04, 0x0f, 0xa2, 0x00, 0x21, 0x03, 0x79, 0x0b, 0x0d, 0x50, 0x0a, 0x38, 0xff, 0x00, 0xe9, 0x0a, 0x06, 0x11, 0x02, 0xc0, 0x0b, 0x2d, 0x09, 0x04, 0xbe, 0x03, 0x0a, 0x43, 0x00, 0x7b, 0x08, 0x79, 0xa0, 0x8e, 0x45, 0xb5, 0xf7, 0x2e, 0x81, 0x49, 0xc0, 0x1e, 0xfc, 0xb7, 0x14, 0x29, 0x84, 0x1d, 0x6a, 0x88, 0x79, 0xd4, 0xbb, 0xe2, 0x73, 0x35, 0x60, 0x4a, 0x5b, 0xff, 0x8d, 0xfd, 0xf8, 0x5d, 0xce, 0xa0, 0x03, 0x13, 0xd9, 0xb2, 0xf7, 0xc0, 0x37, 0x33, 0xd6, 0x54, 0x9e, 0xa3, 0xb8, 0x10, 0xe5, 0x26, 0x2e, 0xd8, 0x44, 0xea, 0x12, 0xf7, 0x09, 0x93, 0xd8, 0x7d, 0x3e, 0x0f, 0x04, 0xe3, 0x97, 0x9e, 0xa0, 0xb5, 0x9e, 0x3c, 0xdd, 0x67, 0x50, 0xfa, 0x8b, 0x15, 0x16, 0x46, 0x12, 0xa5, 0xcb, 0x65, 0x67, 0xcd, 0xfb, 0x38, 0x6d, 0x4e, 0x01, 0x37, 0xfc, 0xce, 0xe5, 0xf3, 0x5a, 0xb5, 0x5d, 0x0e, 0xfd, 0xa0, 0xfe, 0x6d, 0xb5, 0x6e, 0x42, 0xf2, 0x05, 0x7a, 0x07, 0x1c, 0x98, 0x0a, 0x77, 0x8d, 0x9a, 0x0b, 0x61, 0x03, 0x8f, 0x26, 0x9d, 0xd7, 0x4a, 0x0e, 0x90, 0x15, 0x5b, 0x3f, 0x40, 0xf1, 0x43, 0x64, 0xa0, 0x85, 0x38, 0x58, 0x7f, 0x23, 0x78, 0xa0, 0x84, 0x9f, 0x96, 0x08, 0x94, 0x2c, 0xf4, 0x81, 0xda, 0x41, 0x20, 0xc3, 0x60, 0xf8, 0x39, 0x1b, 0xbc, 0xc2, 0x25, 0xd8, 0x11, 0x82, 0x3c, 0x64, 0x32, 0xa0, 0x26, 0xea, 0xc9, 0x4e, 0x75, 0x55, 0x34, 0xe1, 0x6f, 0x95, 0x52, 0xe7, 0x30, 0x25, 0xd6, 0xd9, 0xc3, 0x0d, 0x1d, 0x76, 0x82, 0xa4, 0xcb, 0x5b, 0xd7, 0x74, 0x1d, 0xda, 0xbf, 0xd4, 0x8c, 0x50, 0xa0, 0x41, 0x55, 0x7d, 0xa9, 0xa7, 0x4c, 0xa6, 0x8d, 0xa7, 0x93, 0xe7, 0x43, 0xe8, 0x1e, 0x20, 0x29, 0xb2, 0x83, 0x5e, 0x1c, 0xc1, 0x6e, 0x9e, 0x25, 0xbd, 0x0c, 0x1e, 0x89, 0xd4, 0xcc, 0xad, 0x69, 0x80, 0xa0, 0x41, 0xdd, 0xa0, 0xa4, 0x0a, 0x21, 0xad, 0xe3, 0xa2, 0x0f, 0xcd, 0x1a, 0x4a, 0xbb, 0x2a, 0x42, 0xb7, 0x4e, 0x9a, 0x32, 0xb0, 0x24, 0x24, 0xff, 0x8d, 0xb4, 0xea, 0x70, 0x8a, 0x5e, 0x0f, 0xb9, 0xa0, 0x9a, 0xaf, 0x83, 0x26, 0xa5, 0x1f, 0x61, 0x36, 0x07, 0xa8, 0x68, 0x5f, 0x57, 0x45, 0x83, 0x29, 0xb4, 0x1e, 0x93, 0x8b, 0xb7, 0x61, 0x13, 0x1a, 0x57, 0x47, 0xe0, 0x66, 0xb8, 0x1a, 0x0a, 0x16, 0x80, 0x80, 0x80, 0xa0, 0x22, 0xe6, 0xce, 0xf1, 0x38, 0xe1, 0x6d, 0x22, 0x72, 0xef, 0x58, 0x43, 0x4d, 0xdf, 0x49, 0x26, 0x0d, 0xc1, 0xde, 0x1f, 0x8a, 0xd6, 0xdf, 0xca, 0x3d, 0xa5, 0xd2, 0xa9, 0x2a, 0xaa, 0xad, 0xc5, 0x80, 0x80},
	}

	for _, test := range tests {
		item, nextIndex, err := rlp.ReadListItem(test.encoded, 0, 0)
		require.NoError(t, err)
		require.Equal(t, nextIndex, len(test.encoded))
		for i, expectedItem := range test.items {
			require.Equal(t, item.Get(i), expectedItem)
		}

	}
}

// TODO add nested tests
