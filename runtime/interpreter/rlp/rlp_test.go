/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2020 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rlp_test

import (
	"testing"

	"github.com/onflow/cadence/runtime/interpreter/rlp"
	"github.com/stretchr/testify/require"
)

// TODO Add test cases for all other errors
func TestRLPReadSize(t *testing.T) {
	tests := []struct {
		input          []byte
		startIndex     int
		isString       bool
		dataStartIndex int
		dataSize       int
		errorMsg       string
	}{
		// string test

		// empty data
		{[]byte{}, 0, false, 0, 0, "input data is empty"},
		// out of range index
		{[]byte{0x00}, 1, false, 0, 0, "start index is out of the range"},
		// first char
		{[]byte{0x00}, 0, true, 0, 1, ""},
		// next char
		{[]byte{0x01}, 0, true, 0, 1, ""},
		// last char
		{[]byte{0x7f}, 0, true, 0, 1, ""},
		// empty string
		{[]byte{0x80}, 0, true, 1, 0, ""},
		// start of short string
		{[]byte{0x81}, 0, true, 1, 1, ""},
		// end of short string
		{[]byte{0xb7}, 0, true, 1, 55, ""},
		// start of long string (reading next byte to find out the size and decoding of that byte is smaller than 55)
		{[]byte{0xb8, 0x01}, 0, false, 0, 0, "non canonical encoding"},
		{[]byte{0xb8, 0x37}, 0, false, 0, 0, "non canonical encoding"},
		// first valid long string entry (string len 56, first two bytes used for string size)
		{[]byte{0xb8, 0x38}, 0, true, 2, 56, ""},
		{[]byte{0xb8, 0x39}, 0, true, 2, 57, ""},
		// end of long string with only 1 extra byte (string len 255)
		{[]byte{0xb8, 0xff}, 0, true, 2, 255, ""},
		// long string (string len 256)
		{[]byte{0xb9, 0x01, 0x00}, 0, true, 3, 256, ""},
		// trailing zero bytes are not allowed (ie. the size has to be bigger than 255)
		{[]byte{0xb8, 0x00, 0xff}, 0, false, 0, 0, "non canonical encoding"},
		// several bytes
		{[]byte{0xba, 0x01, 0x00, 0x00}, 0, true, 4, 65536, ""},
		// end of large string (max number of bytes)
		{[]byte{0xbf, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, true, 9, 9223372036854775807, ""},
		// we don't support data size larger than 9223372036854775807
		{[]byte{0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, false, 0, 0, "data size is too large"},

		// list test

		// empty list
		{[]byte{0xc0}, 0, false, 1, 0, ""},
		// short list with 1 byte of data
		{[]byte{0xc1}, 0, false, 1, 1, ""},
		// short list with 55 bytes of data
		{[]byte{0xf7}, 0, false, 1, 55, ""},
		// start of long list (reading next byte to find out the size and decoding of that byte is smaller than 55)
		{[]byte{0xf8, 0x01}, 0, false, 0, 0, "non canonical encoding"},
		{[]byte{0xf8, 0x37}, 0, false, 0, 0, "non canonical encoding"},
		// first valid long string entry (string len 56, first two bytes used for string size)
		{[]byte{0xf8, 0x38}, 0, false, 2, 56, ""},
		{[]byte{0xf8, 0x39}, 0, false, 2, 57, ""},
		// end of long string with only 1 extra byte (string len 255)
		{[]byte{0xf8, 0xff}, 0, false, 2, 255, ""},
		// long list (len 256) 2 extra bytes
		{[]byte{0xf9, 0x01, 0x00}, 0, false, 3, 256, ""},
		// trailing zero bytes are not allowed (ie. the size has to be bigger than 255)
		{[]byte{0xf8, 0x00, 0xff}, 0, false, 0, 0, "non canonical encoding"},
		// several bytes
		{[]byte{0xfa, 0x01, 0x00, 0x00}, 0, false, 4, 65536, ""},
		// end of large list (max number of bytes)
		{[]byte{0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, false, 9, rlp.MaxLongLengthAllowed, ""},
		// we don't support data size larger than 9223372036854775807
		{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, 0, false, 0, 0, "data size is too large"},
	}

	for _, test := range tests {
		isString, dataStartIndex, dataSize, err := rlp.ReadSize(test.input, test.startIndex)
		if len(test.errorMsg) > 0 {
			require.Error(t, err)
			require.Equal(t, test.errorMsg, err.Error())
		} else {
			require.NoError(t, err)
		}
		require.Equal(t, test.isString, isString)
		require.Equal(t, test.dataStartIndex, dataStartIndex)
		require.Equal(t, test.dataSize, dataSize)
	}

}

func TestHappyCaseReadBytesItem(t *testing.T) {
	tests := []struct {
		inp     []byte
		encoded []byte
	}{
		{[]byte(""),
			[]byte{0x80},
		},
		{[]byte("A"),
			[]byte{0x41},
		},
		{[]byte("dog"),
			[]byte{0x83, 0x64, 0x6f, 0x67},
		},
		{[]byte("this is a test lo0o0o0o0o0ong string with 55 characters"),
			[]byte{0xb7, // one byte size
				0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
				0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x6c,
				0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30,
				0x6f, 0x30, 0x6f, 0x6e, 0x67, 0x20, 0x73, 0x74,
				0x72, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69, 0x74,
				0x68, 0x20, 0x35, 0x35, 0x20, 0x63, 0x68, 0x61,
				0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73},
		},
		{[]byte("this is a test lo0o0o0o0o0o0ng string with 56 characters"),
			[]byte{0xb8, 0x38, // an extra byte for size
				0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
				0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x6c,
				0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30, 0x6f, 0x30,
				0x6f, 0x30, 0x6f, 0x30, 0x6e, 0x67, 0x20, 0x73,
				0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69,
				0x74, 0x68, 0x20, 0x35, 0x36, 0x20, 0x63, 0x68,
				0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73},
		},
		{[]byte("Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " +
			"Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus" +
			" et magnis dis parturient montes, nascetur ridiculus mus."),
			[]byte{0xb8, 0xbf, // two byte sizes
				0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75,
				0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69,
				0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f,
				0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x65, 0x72,
				0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e,
				0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x65,
				0x6e, 0x65, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
				0x64, 0x6f, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x20,
				0x65, 0x67, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72,
				0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x6d,
				0x61, 0x73, 0x73, 0x61, 0x2e, 0x20, 0x43, 0x75, 0x6d, 0x20,
				0x73, 0x6f, 0x63, 0x69, 0x69, 0x73, 0x20, 0x6e, 0x61, 0x74,
				0x6f, 0x71, 0x75, 0x65, 0x20, 0x70, 0x65, 0x6e, 0x61, 0x74,
				0x69, 0x62, 0x75, 0x73, 0x20, 0x65, 0x74, 0x20, 0x6d, 0x61,
				0x67, 0x6e, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x20, 0x70,
				0x61, 0x72, 0x74, 0x75, 0x72, 0x69, 0x65, 0x6e, 0x74, 0x20,
				0x6d, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x6e, 0x61,
				0x73, 0x63, 0x65, 0x74, 0x75, 0x72, 0x20, 0x72, 0x69, 0x64,
				0x69, 0x63, 0x75, 0x6c, 0x75, 0x73, 0x20, 0x6d, 0x75, 0x73,
				0x2e},
		},
		{[]byte("Lorem ipsum dolor sit amet, consectetur adipiscing elit. " +
			"Sed imperdiet odio a nibh rutrum blandit. Phasellus porta " +
			"eleifend tellus non consequat. Donec sodales velit in tortor " +
			"iaculis, sollicitudin dignissim orci maximus. Nunc at est sem. Sed congue proin."),
			[]byte{0xb9, 0x01, 0x00, // three bytes for size (256 chars) - checks big endian encoding
				0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d,
				0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20,
				0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65,
				0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70,
				0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74,
				0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x69, 0x6d, 0x70, 0x65, 0x72,
				0x64, 0x69, 0x65, 0x74, 0x20, 0x6f, 0x64, 0x69, 0x6f, 0x20, 0x61,
				0x20, 0x6e, 0x69, 0x62, 0x68, 0x20, 0x72, 0x75, 0x74, 0x72, 0x75,
				0x6d, 0x20, 0x62, 0x6c, 0x61, 0x6e, 0x64, 0x69, 0x74, 0x2e, 0x20,
				0x50, 0x68, 0x61, 0x73, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x70,
				0x6f, 0x72, 0x74, 0x61, 0x20, 0x65, 0x6c, 0x65, 0x69, 0x66, 0x65,
				0x6e, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x6e,
				0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61,
				0x74, 0x2e, 0x20, 0x44, 0x6f, 0x6e, 0x65, 0x63, 0x20, 0x73, 0x6f,
				0x64, 0x61, 0x6c, 0x65, 0x73, 0x20, 0x76, 0x65, 0x6c, 0x69, 0x74,
				0x20, 0x69, 0x6e, 0x20, 0x74, 0x6f, 0x72, 0x74, 0x6f, 0x72, 0x20,
				0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x73, 0x6f,
				0x6c, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x75, 0x64, 0x69, 0x6e, 0x20,
				0x64, 0x69, 0x67, 0x6e, 0x69, 0x73, 0x73, 0x69, 0x6d, 0x20, 0x6f,
				0x72, 0x63, 0x69, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x73,
				0x2e, 0x20, 0x4e, 0x75, 0x6e, 0x63, 0x20, 0x61, 0x74, 0x20, 0x65,
				0x73, 0x74, 0x20, 0x73, 0x65, 0x6d, 0x2e, 0x20, 0x53, 0x65, 0x64,
				0x20, 0x63, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x20, 0x70, 0x72, 0x6f,
				0x69, 0x6e, 0x2e},
		},
	}

	for _, test := range tests {
		item, nextIndex, err := rlp.DecodeString(test.encoded, 0)
		require.NoError(t, err)
		require.Equal(t, nextIndex, len(test.encoded))
		require.Equal(t, item, test.inp)

	}
}

func TestHappyCaseReadListItem(t *testing.T) {
	tests := []struct {
		items   [][]byte
		encoded []byte
	}{
		{
			[][]byte{}, // empty list
			[]byte{0xc0},
		},
		{
			[][]byte{{}}, // list with an empty list
			[]byte{0xc1, 0xc0},
		},
		{
			[][]byte{{}, {}, {}}, // list with several empty list
			[]byte{0xc3, 0xc0, 0xc0, 0xc0},
		},
		{
			[][]byte{[]byte("A")}, // single element
			[]byte{0xc1, 0x41},
		},
		{
			[][]byte{
				[]byte("ABCDEFG"),
				[]byte("HIJKLMN"),
			}, // two short string elements
			[]byte{
				0xd0,                                     // 1 byte size
				0x87,                                     // size of string
				0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, // content
				0x87,                                     // size of string
				0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, // content
			},
		},
		{
			[][]byte{
				[]byte("AB"),
				[]byte("CD"),
				[]byte("EF"),
				[]byte(""),
				[]byte("GH"),
				[]byte(""),
			},
			[]byte{
				0xce, // one byte size
				0x82, 0x41, 0x42,
				0x82, 0x43, 0x44,
				0x82, 0x45, 0x46,
				0x80,
				0x82, 0x47, 0x48,
				0x80},
		},

		{
			[][]byte{
				[]byte("A"),
				[]byte("AB"),
				[]byte("ABC"),
				[]byte("ABCD"),
				[]byte("ABCDE"),
				[]byte("ABCDEF"),
				[]byte("ABCDEFG"),
				[]byte("ABCDEFGH"),
				[]byte("ABCDEFGHI"),
				[]byte("ABCDEFGHIJ"),
				[]byte("ABCDEFGHIJK"),
				[]byte("ABCDEFGHIJKL"),
				[]byte("ABCDEFGHIJKLM"),
				[]byte("ABCDEFGHIJKLMN"),
				[]byte("ABCDEFGHIJKLMNO"),
				[]byte("ABCDEFGHIJKLMNOP"),
				[]byte("ABCDEFGHIJKLMNOPQ"),
				[]byte("ABCDEFGHIJKLMNOPQR"),
				[]byte("ABCDEFGHIJKLMNOPQRS"),
				[]byte("ABCDEFGHIJKLMNOPQRST"),
				[]byte("ABCDEFGHIJKLMNOPQRSTU"),
				[]byte("ABCDEFGHIJKLMNOPQRSTUV"),
				[]byte("ABCDEFGHIJKLMNOPQRSTUVW"),
				[]byte("ABCDEFGHIJKLMNOPQRSTUVWX"),
				[]byte("ABCDEFGHIJKLMNOPQRSTUVWXY"),
				[]byte("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
			},
			[]byte{
				0xf9, 0x01, // two byte size
				0x78, 0x41,
				0x82, 0x41, 0x42,
				0x83, 0x41, 0x42, 0x43,
				0x84, 0x41, 0x42, 0x43, 0x44,
				0x85, 0x41, 0x42, 0x43, 0x44, 0x45,
				0x86, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
				0x87, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
				0x88, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
				0x89, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
				0x8a, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
				0x8b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
				0x8c, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
				0x8d, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
				0x8e, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e,
				0x8f, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
				0x90, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
				0x91, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
				0x92, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,
				0x93, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
				0x94, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,
				0x95, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
				0x96, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
				0x97, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
				0x98, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
				0x99, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
				0x9a, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a},
		},
	}

	for _, test := range tests {
		item, nextIndex, err := rlp.DecodeList(test.encoded, 0)
		require.NoError(t, err)
		require.Equal(t, nextIndex, len(test.encoded))
		for i, expectedItem := range test.items {
			require.Equal(t, item[i], expectedItem)
		}

	}
}

// TODO add test for unhappy case of reading

// TODO test merkle tree test
// sample merkle tree full node encoding
// []byte{0xf9, 0x01, 0x80, 0xaf, 0x0d, 0x07, 0x0a, 0x00, 0x7b, 0x0f, 0x00, 0x43, 0x03, 0x90, 0x0f, 0xa3, 0x06, 0x0b, 0x12, 0x04, 0x0f, 0xa2, 0x00, 0x21, 0x03, 0x79, 0x0b, 0x0d, 0x50, 0x0a, 0x38, 0xff, 0x00, 0xe9, 0x0a, 0x06, 0x11, 0x02, 0xc0, 0x0b, 0x2d, 0x09, 0x04, 0xbe, 0x03, 0x0a, 0x43, 0x00, 0x7b, 0x08, 0x79, 0xa0, 0x8e, 0x45, 0xb5, 0xf7, 0x2e, 0x81, 0x49, 0xc0, 0x1e, 0xfc, 0xb7, 0x14, 0x29, 0x84, 0x1d, 0x6a, 0x88, 0x79, 0xd4, 0xbb, 0xe2, 0x73, 0x35, 0x60, 0x4a, 0x5b, 0xff, 0x8d, 0xfd, 0xf8, 0x5d, 0xce, 0xa0, 0x03, 0x13, 0xd9, 0xb2, 0xf7, 0xc0, 0x37, 0x33, 0xd6, 0x54, 0x9e, 0xa3, 0xb8, 0x10, 0xe5, 0x26, 0x2e, 0xd8, 0x44, 0xea, 0x12, 0xf7, 0x09, 0x93, 0xd8, 0x7d, 0x3e, 0x0f, 0x04, 0xe3, 0x97, 0x9e, 0xa0, 0xb5, 0x9e, 0x3c, 0xdd, 0x67, 0x50, 0xfa, 0x8b, 0x15, 0x16, 0x46, 0x12, 0xa5, 0xcb, 0x65, 0x67, 0xcd, 0xfb, 0x38, 0x6d, 0x4e, 0x01, 0x37, 0xfc, 0xce, 0xe5, 0xf3, 0x5a, 0xb5, 0x5d, 0x0e, 0xfd, 0xa0, 0xfe, 0x6d, 0xb5, 0x6e, 0x42, 0xf2, 0x05, 0x7a, 0x07, 0x1c, 0x98, 0x0a, 0x77, 0x8d, 0x9a, 0x0b, 0x61, 0x03, 0x8f, 0x26, 0x9d, 0xd7, 0x4a, 0x0e, 0x90, 0x15, 0x5b, 0x3f, 0x40, 0xf1, 0x43, 0x64, 0xa0, 0x85, 0x38, 0x58, 0x7f, 0x23, 0x78, 0xa0, 0x84, 0x9f, 0x96, 0x08, 0x94, 0x2c, 0xf4, 0x81, 0xda, 0x41, 0x20, 0xc3, 0x60, 0xf8, 0x39, 0x1b, 0xbc, 0xc2, 0x25, 0xd8, 0x11, 0x82, 0x3c, 0x64, 0x32, 0xa0, 0x26, 0xea, 0xc9, 0x4e, 0x75, 0x55, 0x34, 0xe1, 0x6f, 0x95, 0x52, 0xe7, 0x30, 0x25, 0xd6, 0xd9, 0xc3, 0x0d, 0x1d, 0x76, 0x82, 0xa4, 0xcb, 0x5b, 0xd7, 0x74, 0x1d, 0xda, 0xbf, 0xd4, 0x8c, 0x50, 0xa0, 0x41, 0x55, 0x7d, 0xa9, 0xa7, 0x4c, 0xa6, 0x8d, 0xa7, 0x93, 0xe7, 0x43, 0xe8, 0x1e, 0x20, 0x29, 0xb2, 0x83, 0x5e, 0x1c, 0xc1, 0x6e, 0x9e, 0x25, 0xbd, 0x0c, 0x1e, 0x89, 0xd4, 0xcc, 0xad, 0x69, 0x80, 0xa0, 0x41, 0xdd, 0xa0, 0xa4, 0x0a, 0x21, 0xad, 0xe3, 0xa2, 0x0f, 0xcd, 0x1a, 0x4a, 0xbb, 0x2a, 0x42, 0xb7, 0x4e, 0x9a, 0x32, 0xb0, 0x24, 0x24, 0xff, 0x8d, 0xb4, 0xea, 0x70, 0x8a, 0x5e, 0x0f, 0xb9, 0xa0, 0x9a, 0xaf, 0x83, 0x26, 0xa5, 0x1f, 0x61, 0x36, 0x07, 0xa8, 0x68, 0x5f, 0x57, 0x45, 0x83, 0x29, 0xb4, 0x1e, 0x93, 0x8b, 0xb7, 0x61, 0x13, 0x1a, 0x57, 0x47, 0xe0, 0x66, 0xb8, 0x1a, 0x0a, 0x16, 0x80, 0x80, 0x80, 0xa0, 0x22, 0xe6, 0xce, 0xf1, 0x38, 0xe1, 0x6d, 0x22, 0x72, 0xef, 0x58, 0x43, 0x4d, 0xdf, 0x49, 0x26, 0x0d, 0xc1, 0xde, 0x1f, 0x8a, 0xd6, 0xdf, 0xca, 0x3d, 0xa5, 0xd2, 0xa9, 0x2a, 0xaa, 0xad, 0xc5, 0x80, 0x80},
